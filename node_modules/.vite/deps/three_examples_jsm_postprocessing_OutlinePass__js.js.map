{
  "version": 3,
  "sources": ["../../three/examples/jsm/postprocessing/OutlinePass.js"],
  "sourcesContent": ["import {\r\n\tAdditiveBlending,\r\n\tColor,\r\n\tDoubleSide,\r\n\tHalfFloatType,\r\n\tMatrix4,\r\n\tMeshDepthMaterial,\r\n\tNoBlending,\r\n\tRGBADepthPacking,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tVector2,\r\n\tVector3,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\n\r\n/**\r\n * A pass for rendering outlines around selected objects.\r\n *\r\n * ```js\r\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\r\n * const outlinePass = new OutlinePass( resolution, scene, camera );\r\n * composer.addPass( outlinePass );\r\n * ```\r\n *\r\n * @augments Pass\r\n * @three_import import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';\r\n */\r\nclass OutlinePass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new outline pass.\r\n\t *\r\n\t * @param {Vector2} [resolution] - The effect's resolution.\r\n\t * @param {Scene} scene - The scene to render.\r\n\t * @param {Camera} camera - The camera.\r\n\t * @param {Array<Object3D>} [selectedObjects] - The selected 3D objects that should receive an outline.\r\n\t *\r\n\t */\r\n\tconstructor( resolution, scene, camera, selectedObjects ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * The scene to render.\r\n\t\t *\r\n\t\t * @type {Object}\r\n\t\t */\r\n\t\tthis.renderScene = scene;\r\n\r\n\t\t/**\r\n\t\t * The camera.\r\n\t\t *\r\n\t\t * @type {Object}\r\n\t\t */\r\n\t\tthis.renderCamera = camera;\r\n\r\n\t\t/**\r\n\t\t * The selected 3D objects that should receive an outline.\r\n\t\t *\r\n\t\t * @type {Array<Object3D>}\r\n\t\t */\r\n\t\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\r\n\r\n\t\t/**\r\n\t\t * The visible edge color.\r\n\t\t *\r\n\t\t * @type {Color}\r\n\t\t * @default (1,1,1)\r\n\t\t */\r\n\t\tthis.visibleEdgeColor = new Color( 1, 1, 1 );\r\n\r\n\t\t/**\r\n\t\t * The hidden edge color.\r\n\t\t *\r\n\t\t * @type {Color}\r\n\t\t * @default (0.1,0.04,0.02)\r\n\t\t */\r\n\t\tthis.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );\r\n\r\n\t\t/**\r\n\t\t * Can be used for an animated glow/pulse effect.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 0\r\n\t\t */\r\n\t\tthis.edgeGlow = 0.0;\r\n\r\n\t\t/**\r\n\t\t * Whether to use a pattern texture for to highlight selected\r\n\t\t * 3D objects or not.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.usePatternTexture = false;\r\n\r\n\t\t/**\r\n\t\t * Can be used to highlight selected 3D objects. Requires to set\r\n\t\t * {@link OutlinePass#usePatternTexture} to `true`.\r\n\t\t *\r\n\t\t * @type {?Texture}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.patternTexture = null;\r\n\r\n\t\t/**\r\n\t\t * The edge thickness.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 1\r\n\t\t */\r\n\t\tthis.edgeThickness = 1.0;\r\n\r\n\t\t/**\r\n\t\t * The edge strength.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 3\r\n\t\t */\r\n\t\tthis.edgeStrength = 3.0;\r\n\r\n\t\t/**\r\n\t\t * The downsample ratio. The effect can be rendered in a much\r\n\t\t * lower resolution than the beauty pass.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 2\r\n\t\t */\r\n\t\tthis.downSampleRatio = 2;\r\n\r\n\t\t/**\r\n\t\t * The pulse period.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 0\r\n\t\t */\r\n\t\tthis.pulsePeriod = 0;\r\n\r\n\t\tthis._visibilityCache = new Map();\r\n\t\tthis._selectionCache = new Set();\r\n\r\n\t\t/**\r\n\t\t * The effect's resolution.\r\n\t\t *\r\n\t\t * @type {Vector2}\r\n\t\t * @default (256,256)\r\n\t\t */\r\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\r\n\r\n\t\tconst resx = Math.round( this.resolution.x / this.downSampleRatio );\r\n\t\tconst resy = Math.round( this.resolution.y / this.downSampleRatio );\r\n\r\n\t\tthis.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\r\n\t\tthis.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\r\n\t\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\r\n\r\n\t\tthis.depthMaterial = new MeshDepthMaterial();\r\n\t\tthis.depthMaterial.side = DoubleSide;\r\n\t\tthis.depthMaterial.depthPacking = RGBADepthPacking;\r\n\t\tthis.depthMaterial.blending = NoBlending;\r\n\r\n\t\tthis.prepareMaskMaterial = this._getPrepareMaskMaterial();\r\n\t\tthis.prepareMaskMaterial.side = DoubleSide;\r\n\t\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\r\n\r\n\t\tthis.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, { type: HalfFloatType } );\r\n\t\tthis.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\r\n\t\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\r\n\r\n\t\tthis.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\r\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\r\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\r\n\r\n\t\tthis.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\r\n\t\tthis.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\r\n\t\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\r\n\t\tthis.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), { type: HalfFloatType } );\r\n\t\tthis.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\r\n\t\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\r\n\r\n\t\tthis.edgeDetectionMaterial = this._getEdgeDetectionMaterial();\r\n\t\tthis.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\r\n\t\tthis.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\r\n\t\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\r\n\t\tthis.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), { type: HalfFloatType } );\r\n\t\tthis.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\r\n\t\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\r\n\r\n\t\tconst MAX_EDGE_THICKNESS = 4;\r\n\t\tconst MAX_EDGE_GLOW = 4;\r\n\r\n\t\tthis.separableBlurMaterial1 = this._getSeparableBlurMaterial( MAX_EDGE_THICKNESS );\r\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\r\n\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;\r\n\t\tthis.separableBlurMaterial2 = this._getSeparableBlurMaterial( MAX_EDGE_GLOW );\r\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );\r\n\t\tthis.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;\r\n\r\n\t\t// Overlay material\r\n\t\tthis.overlayMaterial = this._getOverlayMaterial();\r\n\r\n\t\t// copy material\r\n\r\n\t\tconst copyShader = CopyShader;\r\n\r\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\t\tthis.materialCopy = new ShaderMaterial( {\r\n\t\t\tuniforms: this.copyUniforms,\r\n\t\t\tvertexShader: copyShader.vertexShader,\r\n\t\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\t\tblending: NoBlending,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false\r\n\t\t} );\r\n\r\n\t\tthis.enabled = true;\r\n\t\tthis.needsSwap = false;\r\n\r\n\t\tthis._oldClearColor = new Color();\r\n\t\tthis.oldClearAlpha = 1;\r\n\r\n\t\tthis._fsQuad = new FullScreenQuad( null );\r\n\r\n\t\tthis.tempPulseColor1 = new Color();\r\n\t\tthis.tempPulseColor2 = new Color();\r\n\t\tthis.textureMatrix = new Matrix4();\r\n\r\n\t\tfunction replaceDepthToViewZ( string, camera ) {\r\n\r\n\t\t\tconst type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\r\n\r\n\t\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Frees the GPU-related resources allocated by this instance. Call this\r\n\t * method whenever the pass is no longer used in your app.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tthis.renderTargetMaskBuffer.dispose();\r\n\t\tthis.renderTargetDepthBuffer.dispose();\r\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\r\n\t\tthis.renderTargetBlurBuffer1.dispose();\r\n\t\tthis.renderTargetBlurBuffer2.dispose();\r\n\t\tthis.renderTargetEdgeBuffer1.dispose();\r\n\t\tthis.renderTargetEdgeBuffer2.dispose();\r\n\r\n\t\tthis.depthMaterial.dispose();\r\n\t\tthis.prepareMaskMaterial.dispose();\r\n\t\tthis.edgeDetectionMaterial.dispose();\r\n\t\tthis.separableBlurMaterial1.dispose();\r\n\t\tthis.separableBlurMaterial2.dispose();\r\n\t\tthis.overlayMaterial.dispose();\r\n\t\tthis.materialCopy.dispose();\r\n\r\n\t\tthis._fsQuad.dispose();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the size of the pass.\r\n\t *\r\n\t * @param {number} width - The width to set.\r\n\t * @param {number} height - The height to set.\r\n\t */\r\n\tsetSize( width, height ) {\r\n\r\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\r\n\t\tthis.renderTargetDepthBuffer.setSize( width, height );\r\n\r\n\t\tlet resx = Math.round( width / this.downSampleRatio );\r\n\t\tlet resy = Math.round( height / this.downSampleRatio );\r\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\r\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\r\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\r\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\r\n\r\n\t\tresx = Math.round( resx / 2 );\r\n\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\r\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\r\n\r\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs the Outline pass.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\r\n\r\n\t\tif ( this.selectedObjects.length > 0 ) {\r\n\r\n\t\t\trenderer.getClearColor( this._oldClearColor );\r\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\r\n\t\t\tconst oldAutoClear = renderer.autoClear;\r\n\r\n\t\t\trenderer.autoClear = false;\r\n\r\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\r\n\r\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\r\n\r\n\t\t\tthis._updateSelectionCache();\r\n\r\n\t\t\t// Make selected objects invisible\r\n\t\t\tthis._changeVisibilityOfSelectedObjects( false );\r\n\r\n\t\t\tconst currentBackground = this.renderScene.background;\r\n\t\t\tconst currentOverrideMaterial = this.renderScene.overrideMaterial;\r\n\t\t\tthis.renderScene.background = null;\r\n\r\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\r\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\r\n\t\t\trenderer.clear();\r\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\r\n\r\n\t\t\t// Make selected objects visible\r\n\t\t\tthis._changeVisibilityOfSelectedObjects( true );\r\n\t\t\tthis._visibilityCache.clear();\r\n\r\n\t\t\t// Update Texture Matrix for Depth compare\r\n\t\t\tthis._updateTextureMatrix();\r\n\r\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\r\n\t\t\tthis._changeVisibilityOfNonSelectedObjects( false );\r\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\r\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );\r\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;\r\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\r\n\t\t\trenderer.clear();\r\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\r\n\t\t\tthis._changeVisibilityOfNonSelectedObjects( true );\r\n\t\t\tthis._visibilityCache.clear();\r\n\t\t\tthis._selectionCache.clear();\r\n\r\n\t\t\tthis.renderScene.background = currentBackground;\r\n\t\t\tthis.renderScene.overrideMaterial = currentOverrideMaterial;\r\n\r\n\t\t\t// 2. Downsample to Half resolution\r\n\t\t\tthis._fsQuad.material = this.materialCopy;\r\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\r\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\r\n\r\n\t\t\tif ( this.pulsePeriod > 0 ) {\r\n\r\n\t\t\t\tconst scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\r\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\r\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// 3. Apply Edge Detection Pass\r\n\t\t\tthis._fsQuad.material = this.edgeDetectionMaterial;\r\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;\r\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\r\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;\r\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t\t// 4. Apply Blur on Half res\r\n\t\t\tthis._fsQuad.material = this.separableBlurMaterial1;\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t\t// Apply Blur on quarter res\r\n\t\t\tthis._fsQuad.material = this.separableBlurMaterial2;\r\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\r\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;\r\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t\t// Blend it additively over the input texture\r\n\t\t\tthis._fsQuad.material = this.overlayMaterial;\r\n\t\t\tthis.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;\r\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;\r\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;\r\n\t\t\tthis.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;\r\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;\r\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;\r\n\t\t\tthis.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;\r\n\r\n\r\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\r\n\r\n\t\t\trenderer.setRenderTarget( readBuffer );\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\r\n\t\t\trenderer.autoClear = oldAutoClear;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\tthis._fsQuad.material = this.materialCopy;\r\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// internals\r\n\r\n\t_updateSelectionCache() {\r\n\r\n\t\tconst cache = this._selectionCache;\r\n\r\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\r\n\r\n\t\t\tif ( object.isMesh ) cache.add( object );\r\n\r\n\t\t}\r\n\r\n\t\tcache.clear();\r\n\r\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\r\n\r\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\r\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_changeVisibilityOfSelectedObjects( bVisible ) {\r\n\r\n\t\tconst cache = this._visibilityCache;\r\n\r\n\t\tfor ( const mesh of this._selectionCache ) {\r\n\r\n\t\t\tif ( bVisible === true ) {\r\n\r\n\t\t\t\tmesh.visible = cache.get( mesh );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcache.set( mesh, mesh.visible );\r\n\t\t\t\tmesh.visible = bVisible;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_changeVisibilityOfNonSelectedObjects( bVisible ) {\r\n\r\n\t\tconst visibilityCache = this._visibilityCache;\r\n\t\tconst selectionCache = this._selectionCache;\r\n\r\n\t\tfunction VisibilityChangeCallBack( object ) {\r\n\r\n\t\t\tif ( object.isMesh || object.isSprite ) {\r\n\r\n\t\t\t\t// only meshes and sprites are supported by OutlinePass\r\n\r\n\t\t\t\tif ( ! selectionCache.has( object ) ) {\r\n\r\n\t\t\t\t\tconst visibility = object.visible;\r\n\r\n\t\t\t\t\tif ( bVisible === false || visibilityCache.get( object ) === true ) {\r\n\r\n\t\t\t\t\t\tobject.visible = bVisible;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvisibilityCache.set( object, visibility );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.isPoints || object.isLine ) {\r\n\r\n\t\t\t\t// the visibility of points and lines is always set to false in order to\r\n\t\t\t\t// not affect the outline computation\r\n\r\n\t\t\t\tif ( bVisible === true ) {\r\n\r\n\t\t\t\t\tobject.visible = visibilityCache.get( object ); // restore\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvisibilityCache.set( object, object.visible );\r\n\t\t\t\t\tobject.visible = bVisible;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\r\n\r\n\t}\r\n\r\n\t_updateTextureMatrix() {\r\n\r\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\r\n\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t0.0, 0.0, 0.0, 1.0 );\r\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\r\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\r\n\r\n\t}\r\n\r\n\t_getPrepareMaskMaterial() {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t'depthTexture': { value: null },\r\n\t\t\t\t'cameraNearFar': { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t'textureMatrix': { value: null }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t`#include <batching_pars_vertex>\r\n\t\t\t\t#include <morphtarget_pars_vertex>\r\n\t\t\t\t#include <skinning_pars_vertex>\r\n\r\n\t\t\t\tvarying vec4 projTexCoord;\r\n\t\t\t\tvarying vec4 vPosition;\r\n\t\t\t\tuniform mat4 textureMatrix;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\t#include <batching_vertex>\r\n\t\t\t\t\t#include <skinbase_vertex>\r\n\t\t\t\t\t#include <begin_vertex>\r\n\t\t\t\t\t#include <morphtarget_vertex>\r\n\t\t\t\t\t#include <skinning_vertex>\r\n\t\t\t\t\t#include <project_vertex>\r\n\r\n\t\t\t\t\tvPosition = mvPosition;\r\n\r\n\t\t\t\t\tvec4 worldPosition = vec4( transformed, 1.0 );\r\n\r\n\t\t\t\t\t#ifdef USE_INSTANCING\r\n\r\n\t\t\t\t\t\tworldPosition = instanceMatrix * worldPosition;\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\tworldPosition = modelMatrix * worldPosition;\r\n\r\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t`#include <packing>\r\n\t\t\t\tvarying vec4 vPosition;\r\n\t\t\t\tvarying vec4 projTexCoord;\r\n\t\t\t\tuniform sampler2D depthTexture;\r\n\t\t\t\tuniform vec2 cameraNearFar;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\r\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\r\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\r\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\r\n\r\n\t\t\t\t}`\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_getEdgeDetectionMaterial() {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t'maskTexture': { value: null },\r\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t'visibleEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\r\n\t\t\t\t'hiddenEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t`varying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t`varying vec2 vUv;\r\n\r\n\t\t\t\tuniform sampler2D maskTexture;\r\n\t\t\t\tuniform vec2 texSize;\r\n\t\t\t\tuniform vec3 visibleEdgeColor;\r\n\t\t\t\tuniform vec3 hiddenEdgeColor;\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\r\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\r\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\r\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\r\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\r\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\r\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\r\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\r\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\r\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\r\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\r\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\r\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\r\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\r\n\t\t\t\t}`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_getSeparableBlurMaterial( maxRadius ) {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t'MAX_RADIUS': maxRadius,\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t'colorTexture': { value: null },\r\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t'kernelRadius': { value: 1.0 }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t`varying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t`#include <common>\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tuniform sampler2D colorTexture;\r\n\t\t\t\tuniform vec2 texSize;\r\n\t\t\t\tuniform vec2 direction;\r\n\t\t\t\tuniform float kernelRadius;\r\n\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\r\n\t\t\t\t\tfloat sigma = kernelRadius/2.0;\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, sigma);\r\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\r\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\r\n\t\t\t\t\tvec2 uvOffset = delta;\r\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\r\n\t\t\t\t\t\tfloat x = kernelRadius * float(i) / float(MAX_RADIUS);\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, sigma);\r\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\r\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\r\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\r\n\t\t\t\t\t\tweightSum += (2.0 * w);\r\n\t\t\t\t\t\tuvOffset += delta;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\r\n\t\t\t\t}`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_getOverlayMaterial() {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t'maskTexture': { value: null },\r\n\t\t\t\t'edgeTexture1': { value: null },\r\n\t\t\t\t'edgeTexture2': { value: null },\r\n\t\t\t\t'patternTexture': { value: null },\r\n\t\t\t\t'edgeStrength': { value: 1.0 },\r\n\t\t\t\t'edgeGlow': { value: 1.0 },\r\n\t\t\t\t'usePatternTexture': { value: 0.0 }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t`varying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t`varying vec2 vUv;\r\n\r\n\t\t\t\tuniform sampler2D maskTexture;\r\n\t\t\t\tuniform sampler2D edgeTexture1;\r\n\t\t\t\tuniform sampler2D edgeTexture2;\r\n\t\t\t\tuniform sampler2D patternTexture;\r\n\t\t\t\tuniform float edgeStrength;\r\n\t\t\t\tuniform float edgeGlow;\r\n\t\t\t\tuniform bool usePatternTexture;\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\r\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\r\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\r\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\r\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\r\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\r\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\r\n\t\t\t\t\tif(usePatternTexture)\r\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\r\n\t\t\t\t\tgl_FragColor = finalColor;\r\n\t\t\t\t}`,\r\n\t\t\tblending: AdditiveBlending,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\ttransparent: true\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nOutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );\r\nOutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );\r\n\r\nexport { OutlinePass };\r\n"],
  "mappings": "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",
  "names": ["camera"]
}
